Конфигурация
============

На всех девелоперских машинах обязательно иметь настроенными

    git config --global user.name "User Name"
    git config --global user.email "user@example.com"

У каждого коммиттера должна быть своя уникальная пара user.name / user.email,
чтобы знать, кого бить по рукам в случае чего. Коммиттеры не должны использовать
больше одной такой пары, чтобы не портить статистику.

Рекомендуется также настроить (по вкусу)

    git config --global rerere.enabled true
    git config --global color.diff auto
    git config --global color.interactive auto
    git config --global color.status auto

Ставим git-email для отправки готовых фичей на ревью лидам проекта

    sudo apt-get install git-email

Правим конфиг send-email на отсылку патчей (используем gmail'овский smtp сервер)

    git config --global sendemail.smtpserver smtp.gmail.com
    git config --global sendemail.smtpserverport 587
    git config --global sendemail.smtpencryption tls
    git config --global sendemail.smtpuser your_email@gmail.com
    git config --global sendemail.smtppass your_password
    git config --global sendemail.assume8bitEncoding utf-8

(Последний пункт необходим и тем, кто gmail для отсылки патчей не использует.)

Для правильной нумерации патчей в патчсетах, отправляемых на ревью, делаем:

    git config --global format.numbered true

Если в проекте есть etc/git/hooks, то его нужно обязательно подключить: находясь
в корневой директории проекта выполнить

    rm -r .git/hooks
    ln -s ../etc/git/hooks/ .git/hooks

Коммиты
=======

1. Коммитим помельче — атомарными смысловыми кусками. Пользуемся возможностью
   закоммитить часть файла (hunk). Но без фанатизма — если сильно
   долго разбирать лапшу, можно в качестве исключения закоммитить всё сразу.
   При этом явно отмечаем в commit message, почему так сделано.

2. Сообщения о коммитах — на английском (можно на ломанном). Кириллицу иногда
   тяжело просматривать в консоли на сервере.

3. Первая строка в сообщении о коммите — краткое описание того, что случилось
   (до 50-ти символов, не строго).

4. Если нужно детальное описание — оно идёт с отбивкой пустой строкой.
   Стандартные гитовые тулзы заточены на такой формат.
   (см. http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)

5. В одном коммите не должно быть смешения рукописного и генерированного кода.

6. Любой комментарий с TODO, обязан содержать ссылку на тикет в редмайне
   (проекты на GitHub -- ссылку на issue, подробнее см. раздел про тикеты на GH)

7. Не допускается объединение в один коммит перемещения (переименования) файла и
   изменения его содержимого. Изменения файла должны идти отдельным коммитом.

8. При перемещении файлов не допускается разделение на два коммита
   удаления файла из старого места и добавления файла в новое. И удаление
   и добавление одного и того же файла обязательно должны идти одним коммитом.

9. При заведении нового репозитория первый коммит должен иметь сообщение
   `initial commit` и содержать следующие файлы:
   - .gitignore (копируем из pk-project-tools)
   - README - содержит название проекта, copyright, ссылку на файл с описанием
     лицензии (описано в гугледокументе "Правила оформления лицензии на код")
   - COPYRIGHT - содержит подробное описание лицензии
     (описано в гугледокументе "Правила оформления лицензии на код")
   - etc/git/hooks/pre-commit - git hook последней версии, принятой для проектов
     (копируем из pk-project-tools)

   `Initial commit` обязательно отправляется на ревью (см. Ревью кода).
   Для создания патчсета можно использовать следующую команду:

    git format-patch --root $SHA

   $SHA - хэш первого коммита.

Ветки
=====

Делаем push на сервер почаще. Приятно видеть хотя бы один пуш в день.

Ветку master не трогаем ни при каких обстоятельствах — её трогает только
maintainer.

Все остальные не "системные" ветки называем с префиксом:
`<developer-initials>/<branch-name>` (`ag/mybranch`, `ik/otherbranch`)

Ветки, относящиеся к тикетам (фичебранчи), должны после инциалов содержать номер
тикета: `ag/555/short_summary`.

Ветки, на повторном ревью должны содержать номер итерации:
`ag/mybranch_v2` (см. раздел _Ревью кода_). Для веток вида
`ag/555/short_summary` новая ветка будет `ag/555/short_summary_v2`.
При блокирующих ревью меняем историю ветки, а не досылаем патчи.

За исключением особых случаем используем подход с feature (aka topic) branches —
по ветке на фичу. Однако, приветствуется т.н. оппортунистический рефакторинг
— исправление, обобщение, приведение к гайдлайнам старого кода по ходу дела.
Такие изменения необходимо оформлять отдельными коммитами и помечать явно,
с тем, чтобы при ревью возникало меньше вопросов.

Новые ветки начинаем от `master` для библиотечных проектов и от `dev` для остальных
(а еще лучше предварительно уточнить у майнтейнера откуда начинать).

Если майнтейнер тормозит с обновлением мастера, вполне допускается начать ветку
от невлитой ветки с нужными фичами (майнтейнеру при этом нужно выписать пинка,
чтобы не тормозил).

Регулярно перематываем (`git rebase`) ветки, находящиеся в работе, к мастеру, чтобы
облегчить слияние в конце разработки. В идеале — перематываем каждый раз когда
мастер изменяется.

Когда работа над веткой завершена, делаем ей `git rebase master`, тестируем и даём
мейнтейнеру отмашку на вливание ветки в мастер. Влитые в мастер ветки стираем
(либо ресетим к мастеру, если очень хочется сохранить).

(Для прикладных /не библиотечных/ проектов.) На каждую инсталляцию есть по ветке
(обычно называются по имени хоста, без префикса), голова которой указывает на
тот код, который сейчас вылит на эту инсталляцию. Эти ветки контролирует и
обновляет тот, кто производит выливку на соответствующие инсталляции (может быть
несколько человек, если это, например, инсталляция для первичного тестирования).

Во многих проектах есть директория lib, в которой живут зависимости. Некоторые
из этоих зависимостей могут быть притянуты как `git subtree`. *Коммититься в них
из репозитория проекта нельзя ни в коем случае.* Нужно сделать коммит в основной
репозиторий, запушиться и притянуть правки (обычно через `bin/update-subtrees
update`).

Нельзя проводить `update-subtree` для feature branches, предназначенных для
вливания в dev (такая ветка нарушает линейность истории разработки и может
создать проблемы при проведении `git rebase`). Для отладки следует использовать
временные ветки, не предназначенные для вливания в dev.

В зависимости от проекта и библиотеки могут быть шорткаты для тестирования —
спрашивайте лидов :)

Тестовая выливка кода
=====================

Если изменения вносились в любой из библиотечных проектов, притягиваемых в
финальные проекты как subtree, необходимо проверить, что эти изменения не
портят финальные проекты. Тестовую выливку *желательно* делать перед отправкой
кода на ревью и *обязательно* делать после того, как патч был принят и залит в
удаленный репозиторий (если она не делалась ранее).

#Порядок тестовой выливки

1. Запушить изменения в удаленный репозиторий, если этого еще не было сделано.
Для выливки перед ревью пушится рабочая ветка кода.
2. Создать тестовую ветку в финальном проекте.
3. Подтянуть в тестовую ветку изменения как subtree.
4. Подеплоиться на локалхост.
5. Запустить тесты и убедиться, что ничего не сломалось. Как минимум необходимо
запускать "does it work", желательно запускать полный набор тестов.

Ревью кода
==========

После завершение работы над тикетом соответствующая ветка посылается в виде
patch series на ревью кода лидом проекта.

Если разработка по задаче затягивается, то необходимо посылать промежуточные
ревью текущего состояния кода не реже чем раз в три дня, если заранее
не оговорено иное.

Проекты на гитхабе (lua-nucleo, lua-aplicado...) мы ревьюим на общих основаниях,
через почту.

В lua-nucleo, lua-aplicado ВСЕ ревью — БЛОКИРУЮЩИЕ.

Любые массовые операции поиска и замены в обязательном порядке нужно
оформлять отдельным коммитом. Иначе невозможно толком ревьюить.

Допускается их оформление отдельным патчсетом (но можно группировать
по нескольку переименований) — чтобы потом не париться с вычленением
правок.

##Git & e-mail

###Формируем patch'и

    git format-patch -n --cover-letter master

С указанием каталога, куда положить файлы:

    git format-patch -n --cover-letter -o ~/projects/review master

Патч должен быть для той ветки, от которой растет ветка с правками, т.е. для
некоторых проектов это будет не `master`, а `dev` (см. раздел _Ветки_)

    git format-patch -n --cover-letter -o ~/projects/review dev

###Редактируем patch

Открываем файл `0000-cover-letter.patch` на редактирование:

1. Правим 4-ю строчку Subject:
   `[PATCH 0/3] *** SUBJECT HERE ***` таким образом, чтобы получилось следующее:
   `[PATCH 0/3] changes_short_sumary | project_name | ag/555/branch_name`

2. Ниже (вместо `*** BLURB HERE ***`) добавляем *ссылку на соответствующий тикет*
   и краткое описание что и как было сделано по задаче.
   Для повторного ревью также - что было исправлено/переделано.

3. Во всех остальных файлах вида `0001-commit-message.patch` дополняем Subject:
   `[PATCH 1/3] commit message` до
   `[PATCH 1/3] commit message | project_name | ag/555/branch_name`

4. Вместо `pk-format-patch` рекомендуется использовать утилиту
   `pk-git-format-patch` из комплекта `pk-git-utils`
   http://github.com/logiceditor-com/pk-git-utils

    Утилиты не требуют установки, достаточно добавить `scripts/` оттуда в `PATH`, или
    сделать симлинк в `~/bin`, или иной каталог который уже перечислен в `PATH`:

        mkdir -p ~/bin
        cd ~/projects && git clone http://github.com/logiceditor-com/pk-git-utils
        ln -s ~/projects/pk-git-utils/scripts/pk-git-format-patch ~/bin

    и добавьте в `.bashrc`:

        export PATH=~/bin:$PATH

    Утилита `pk-git-format-patch` является "надстройкой" над стандартным format-patch,
    и форматирует заголовок письма как рекомендовано в данном документе.

###Отправляем на ревью:

    git send-email --to 'logiceditor-com-review@googlegroups.com' *.patch

Для новичков — посылать в probation:

    git send-email --to 'logiceditor-com-probation@googlegroups.com' *.patch

*Внимание!* Максимальный размер письма в 4Мб. Будьте аккуратны и не отсылайте
графические ресурсы в бинарном коде на ревью!
Тексты бинарных файлов, а также тексты внешних ресурсов (библиотек) необходимо
заменять на "Здесь был <указать что здесь было>". Например, "Здесь был бинарный файл"
или "Здесь был минифицированный скрипт".

##Redmine

Алгоритм работы с тикетом:

1. Написать, что отправлено на ревью.

2. Установить соответствущий статус (*On Blocking/Nonblocking Review*) и передать
тикет ревьюеру.

Ревьюер должен отметиться и в тикете и в треде с ревью (в одном из мест можно
написать только результат: принято/не принято,  дублировать в оба места
не нужно) и вернуть тикет автору со статусом *Review Feedback*.

Если ревьюер забыл отметиться в тикете, то автору правок следует самостоятельно
вернуть себе тикет, описав результат прошедшего ревью (достаточно написать
только результат: принято/не принято).

##GitHub

Алгоритм работы с ветками и issues на гитхабе

(Только для тех наших проектах, с открытым исходным которые мы  держим там,
читай lua-nucleo, lua-aplicado и те "не наши" в которые мы активно контибутим
— lua-posix, luarocks etc.)

Тикет на GitHub с одной целью: чтобы оставить в опенсурсном коде
ссылку на тикет рядом с TODO. Если в коде ссылку не оставляем, тикет
не заводим.

Тикет на GitHub обязательно должен быть самодостаточным! Номер в нашем
редмайне — просто как референс. Симметричный тикет в корпоративном редмайне
не обязан быть самодостаточным и может содержать только ссылку на тикет в ГХ.

1. Заводим тикет в "внутреннем" редмайне

2. Заводим парный ему тикет в issues гитхаба, на английском.
   Указываем там номер тикета из пункта 1 в виде #NNN без указания трекера.

3. Идем в корпоративный редмайн и добавляем в тикет ссылку на issue в гитхабе.

Общие рекомендации
==================

Не стоит пользоваться заглавными буквами в именах файлов без крайней нужды.
